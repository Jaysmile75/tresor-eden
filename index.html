<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Le Tr√©sor d‚ÄôEden ‚Äì Chasse au tr√©sor</title>
  <style>
    * { box-sizing: border-box; }
   /* Fond pirate sur tout le jeu */
html, body{
  margin:0;
  height:100%;
  background: #0f172a url('assets/pirate.png') center / cover no-repeat fixed;
}

    #game { position: relative; width: 100%; height: 100vh; overflow: hidden; color: #fff; display:flex; align-items:center; justify-content:center; }
    .scene { position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; padding: 16px; text-align:center; gap: 24px; opacity:0; transform: translateY(8px); pointer-events:none; transition: opacity 500ms ease, transform 500ms ease; }
    .scene.active { opacity:1; transform: translateY(0); pointer-events:auto; }
    .card { background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03)); border: 1px solid rgba(255,255,255,0.12); border-radius: 20px; padding: 20px; backdrop-filter: blur(6px); box-shadow: 0 10px 30px rgba(0,0,0,0.35); max-width: 920px; width: min(92vw, 920px); }
    h1 { font-size: clamp(28px, 4.5vw, 48px); margin:0; }
    h2 { font-size: clamp(22px, 3.5vw, 34px); margin:0 0 8px 0; }
    p  { font-size: clamp(16px, 2.5vw, 22px); margin: 0; opacity: .95; }
    .btn { font-size: clamp(18px, 3vw, 28px); padding: 14px 24px; border-radius: 16px; border: none; cursor: pointer; color:#0f172a; background:#fbbf24; box-shadow: 0 8px 20px rgba(251,191,36,.35); transition: transform .1s ease; }
    .btn:active { transform: translateY(2px) scale(.98); }
    .progress { position:absolute; top:12px; left:50%; transform:translateX(-50%); display:flex; gap:6px; z-index: 20; }
    .piece { width: 28px; height: 28px; border-radius: 6px; border:1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.08); display:grid; place-items:center; font-weight:700; font-size:14px; }
    .piece.collected { background:#34d399; border-color:#10b981; }
    .board { display:grid; gap: 16px; justify-content:center; align-items:center; margin-top: 8px; }
    .board.cols-3 { grid-template-columns: repeat(3, min(26vw, 200px)); }
    .option { display:flex; align-items:center; justify-content:center; text-align:center; height: min(26vw, 200px); width: min(26vw, 200px); background:#1f2937; border:2px solid #334155; border-radius: 24px; padding: 10px; font-size: clamp(20px, 5.5vw, 42px); user-select:none; cursor:pointer; transition: transform .12s ease, border-color .2s ease, background .2s ease; }
    .option:active { transform: scale(.98); }
    .option.wrong { animation: wobble .4s ease; border-color:#f87171; }
    .option.correct { border-color:#10b981; background:#064e3b; }
    @keyframes wobble { 0% { transform: translateX(0); } 25% { transform: translateX(-6px); } 50% { transform: translateX(6px); } 75% { transform: translateX(-3px); } 100% { transform: translateX(0); } }
    .ribbon { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:8px; }
    .badge { background:#111827; border:1px solid rgba(255,255,255,.2); border-radius:999px; padding:8px 12px; font-size:14px; opacity:.9; display:flex; align-items:center; justify-content:center; }
    .sticker { position:absolute; z-index: 25; width: 72px; height:72px; display:grid; place-items:center; border-radius: 999px; background: radial-gradient(circle at 30% 30%, #ffffff, #fde68a); box-shadow: 0 8px 22px rgba(0,0,0,.35); cursor:pointer; animation: float 3s ease-in-out infinite; user-select:none; display:none; }
    .sticker small { color:#0f172a; font-weight:700; }
    @keyframes float { 0% { transform: translateY(0); } 50% { transform: translateY(-8px);} 100% { transform: translateY(0);} }
    /* Puzzle zone */
    .puzzle { width: min(92vw, 720px); height: min(70vh, 420px); background: #0b1022; border:2px dashed rgba(255,255,255,.25); border-radius: 16px; margin: 0 auto; position:relative; touch-action:none; overflow:hidden; }
    .puzzle::after{ content:''; position:absolute; inset:0; background-size: cover; background-position: center; opacity:.12; pointer-events:none; border-radius: 16px; }
    .piece-draggable { position:absolute; background-repeat:no-repeat; background-size: cover; border:1px solid rgba(255,255,255,.25); border-radius: 12px; display:block; user-select:none; touch-action:none; cursor:grab; }
    .slot { position:absolute; border:2px dashed rgba(255,255,255,.3); border-radius: 14px; background-repeat:no-repeat; background-size: cover; background-position:center; opacity:.18; }
    .slot.filled { border-color:#10b981; opacity:.0; }
    #fx, #confetti { position:absolute; inset:0; pointer-events:none; }
    .topbar { position:absolute; top:10px; left:10px; display:flex; gap:8px; z-index:30; }
    .ghost { background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.18); color:#fff; padding:8px 12px; border-radius:10px; font-size:14px; cursor:pointer; }
    .hint { font-size: 18px; opacity:.9; }
    /* R√©duction sur mobile tr√®s petit */
    @media (max-width: 420px) {
      .sticker { width:60px; height:60px; }
    }
  </style>
</head>
<body>
<div id="game">
  <canvas id="confetti"></canvas>
  <canvas id="fx"></canvas>

  <div class="progress" id="progress"></div>

<div class="topbar">
  <button class="ghost" id="btnSound">üîä sons</button>
  <button class="ghost" id="btnReplay" style="display:none">‚Ü∫ rejouer</button>
  <button class="ghost" id="btnShuffle">üé≤ al√©atoire: off</button>
</div>


  <div class="scene active" id="scene0">
    <div class="card">
      <h1>Le Tr√©sor d‚ÄôEden</h1>
      <p>Salut Eden ! Un tr√©sor est cach√©. Pr√™t √† le trouver ?</p>
      <div class="ribbon">
        <span class="badge"><img src="assets/eden.png" alt="Eden" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Rose.png" alt="Rose" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Dimitry.png" alt="Dimitry" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Cyndel.png" alt="Cyndel" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Julien.png" alt="Papa Julien" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Violette.png" alt="Maman Violette" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Jerome.png" alt="Tonton J√©r√¥me" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Justine.png" alt="Tata Justine" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Alison.png" alt="Tata Alison" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
        <span class="badge"><img src="assets/Maminou.png" alt="Maminou" style="width:60px;height:60px;border-radius:50%;object-fit:cover;"></span>
      </div>
      <br/>
      <button class="btn" id="startBtn">Jouer</button>
    </div>
  </div>

<div class="scene" id="scene1">
    <div class="card">
      <h2>Avec quoi maman soigne les bobos ?</h2>
      <p class="hint">Choisis le bon</p>
      <div class="board cols-3">
        <div class="option" data-correct="false">üß∏</div>
        <div class="option" data-correct="true">ü©π</div>
        <div class="option" data-correct="false">üéà</div>
      </div>
    </div>
  </div>

<div class="scene" id="scene2">
    <div class="card">
      <h2>Comment est habill√© papa pour aller au travail ?</h2>
      <p class="hint">Choisis la bonne tenue</p>
      <div class="board cols-3">
        <div class="option" data-correct="false">ü•ã</div>
        <div class="option" data-correct="true">ü¶∫</div>
        <div class="option" data-correct="false">üëî</div>
      </div>
    </div>
  </div>

<div class="scene" id="scene3">
    <div class="card">
      <h2>Quel est l'animal pr√©f√©r√© de Rose ?</h2>
      <p class="hint">Choisis le bon animal</p>
      <div class="board cols-3">
        <div class="option" data-correct="false">üêº</div>
        <div class="option" data-correct="false">ü¶Å</div>
        <div class="option" data-correct="true">ü¶Ñ</div>
      </div>
    </div>
  </div>

<div class="scene" id="scene4">
    <div class="card">
      <h2>Terrain de jeu avec Dimitry</h2>
      <p class="hint">√Ä quoi adore jouer Dimitry ? </p>
      <div class="board cols-3">
        <div class="option" data-correct="false">‚öΩÔ∏è</div>
        <div class="option" data-correct="false">üõù</div>
        <div class="option" data-correct="true">üéÆ</div>
      </div>
    </div>
  </div>

  <div class="scene" id="scene5">
    <div class="card">
      <h2>Activit√© avec Cyndel</h2>
      <p class="hint">Comment s'habillait Cyndel pour aller chez les pompiers ?</p>
      <div class="board cols-3">
        <div class="option" data-correct="true">üßë‚Äçüöí</div>
        <div class="option" data-correct="false">üëÆ</div>
        <div class="option" data-correct="false">üë∑‚Äç‚ôÄÔ∏è</div>
      </div>
    </div>
  </div>

  <div class="scene" id="scene6">
    <div class="card">
      <h2>Chez Maminou</h2>
      <p class="hint">Assemble les 6 morceaux de l'image pour d√©couvrir le tr√©sor cach√© chez Maminou</p>
      <div class="puzzle" id="puzzle"></div>
      <div style="margin-top:16px;">
        <button class="btn" id="openChest" style="display:none;">Ouvrir le coffre</button>
      </div>
    </div>
  </div>

  <div class="scene" id="scene7">
    <div class="card">
      <h2>Bravo Eden !</h2>
      <p>Joyeux Anniversaire üéâ Tu as trouv√© le tr√©sor.</p>
      <div style="margin-top:12px; font-size:20px; opacity:.9;">
        Indice secret: regarder sur le lit de chez Maminou pour d√©couvrir le tr√©sor cach√©.
      </div>
      <div style="margin-top:16px;">
        <button class="btn" id="playAgain">Rejouer</button>
      </div>
      <div style="margin-top:16px; font-size:16px; opacity:.8;" id="stickersWall"></div>
    </div>
  </div>

  <!-- Les bulles seront g√©n√©r√©es en JS -->
</div>

<script>
(() => {
  const scenes = Array.from(document.querySelectorAll('.scene'));
  const progress = document.getElementById('progress');
  const confettiCanvas = document.getElementById('confetti');
  const fxCanvas = document.getElementById('fx');
  const btnReplay = document.getElementById('btnReplay');
  const btnSound = document.getElementById('btnSound');
  const btnShuffle = document.getElementById('btnShuffle');

// Mode al√©atoire (questions + ordre des r√©ponses)
let randomMode = false; // toggle via bouton
btnShuffle.addEventListener('click', () => {
  randomMode = !randomMode;
  btnShuffle.textContent = randomMode ? 'üé≤ al√©atoire: on' : 'üé≤ al√©atoire: off';
});

// Ordre des sc√®nes de questions (1‚Üí5)
let questionOrder = [1,2,3,4,5];

// petit utilitaire de m√©lange (Fisher‚ÄìYates)
function shuffleArray(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = (Math.random()*(i+1))|0;
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

// m√©lange des options d‚Äôune sc√®ne
function shuffleOptions(sceneId){
  const board = document.querySelector(`#scene${sceneId} .board`);
  if(!board) return;
  const opts = Array.from(board.children);
  shuffleArray(opts);
  opts.forEach(el => board.appendChild(el)); // r√©ins√®re dans un ordre al√©atoire
}

// calcule l‚Äôordre des questions et m√©lange les r√©ponses si besoin
function computeOrder(){
  questionOrder = [1,2,3,4,5];
  if (randomMode) shuffleArray(questionOrder);
  if (randomMode) [1,2,3,4,5].forEach(id => shuffleOptions(id));
}

// va √† la prochaine sc√®ne selon l‚Äôordre courant, sinon envoie au puzzle (6)
function advanceFromScene(sceneId){
  const i = questionOrder.indexOf(sceneId);
  if (i > -1 && i < questionOrder.length-1) {
    gotoScene(questionOrder[i+1]);
  } else {
    gotoScene(6); // puzzle
  }
}


  // Musique de fond
  const bgm = new Audio('assets/PiratesDesCarabesMusiqueComplte_vbr.mp3');
  bgm.loop = true;
  bgm.volume = 0.35;

  let current = 0;
  let pieces = 0;
  let soundsEnabled = true;

  function sfx(type='ok'){
    if(!soundsEnabled) return;
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type === 'ok' ? 'triangle' : type === 'bad' ? 'sawtooth' : 'sine';
    o.frequency.value = type === 'ok' ? 660 : type === 'bad' ? 140 : 520;
    o.connect(g); g.connect(ctx.destination);
    g.gain.setValueAtTime(.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(.2, ctx.currentTime + .02);
    g.gain.exponentialRampToValueAtTime(.0001, ctx.currentTime + .25);
    o.start(); o.stop(ctx.currentTime + .26);
  }

  function renderProgress(){
    progress.innerHTML = '';
    for(let i=0;i<6;i++){
      const el = document.createElement('div');
      el.className = 'piece' + (i < pieces ? ' collected' : '');
      el.textContent = i < pieces ? '‚úì' : (i+1);
      progress.appendChild(el);
    }
  }
  renderProgress();

  function gotoScene(i){
    scenes[current].classList.remove('active');
    current = i;
    scenes[current].classList.add('active');
    toggleStickers();
  }

  // Canvases
  const cCtx = confettiCanvas.getContext('2d');
  function resizeCanvases(){
    [confettiCanvas, fxCanvas].forEach(cv => { cv.width = window.innerWidth; cv.height = window.innerHeight; });
  }
  window.addEventListener('resize', resizeCanvases);
  resizeCanvases();

  function confettiBurst(x=window.innerWidth/2, y=window.innerHeight/2){
    const parts = [];
    const colors = ['#fbbf24','#34d399','#60a5fa','#f472b6','#f87171'];
    for(let i=0;i<80;i++){
      parts.push({ x, y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.8)*6-3, g:0.1 + Math.random()*0.15, s: 4 + Math.random()*4, a: 1, col: colors[(Math.random()*colors.length)|0] });
    }
    let t=0;
    function step(){
      t++;
      cCtx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
      parts.forEach(p => {
        p.x += p.vx; p.y += p.vy; p.vy += p.g; p.a -= 0.008;
        cCtx.globalAlpha = Math.max(p.a, 0);
        cCtx.fillStyle = p.col;
        cCtx.fillRect(p.x, p.y, p.s, p.s);
      });
      cCtx.globalAlpha = 1;
      if(t < 220) requestAnimationFrame(step);
    }
    step();
  }

  const fCtx = fxCanvas.getContext('2d');
  let fwAnim = null;
  function fireworks(){
    cancelAnimationFrame(fwAnim);
    const rockets = [];
    const Wc = fxCanvas.width, Hc = fxCanvas.height;
    const colors = ['#ffd166','#06d6a0','#118ab2','#ef476f','#a78bfa'];

    function spawn(){
      rockets.push({ x: Math.random()*Wc*0.8 + Wc*0.1, y: Hc + 10, vx: (Math.random()-0.5)*1.2, vy: - (6 + Math.random()*3), exploded:false, col: colors[(Math.random()*colors.length)|0] });
    }

    let last = 0;
    function step(ts){
      fCtx.fillStyle = 'rgba(15,23,42,0.3)';
      fCtx.fillRect(0,0,Wc,Hc);
      if(ts - last > 500){ last = ts; spawn(); }

      for(let i=rockets.length-1;i>=0;i--){
        const r = rockets[i];
        if(!r.exploded){
          r.x += r.vx; r.y += r.vy; r.vy += 0.08;
          fCtx.fillStyle = r.col; fCtx.fillRect(r.x, r.y, 3, 3);
          if(r.vy > -1){
            r.exploded = true; r.parts = [];
            for(let k=0;k<80;k++){
              r.parts.push({x:r.x, y:r.y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life: 60 + (Math.random()*40|0)});
            }
          }
        } else {
          for(let j=r.parts.length-1;j>=0;j--){
            const p = r.parts[j];
            p.x += p.vx; p.y += p.vy; p.vy += 0.02; p.life--;
            fCtx.fillStyle = r.col; fCtx.fillRect(p.x, p.y, 2, 2);
            if(p.life<=0) r.parts.splice(j,1);
          }
          if(r.parts.length===0) rockets.splice(i,1);
        }
      }
      fwAnim = requestAnimationFrame(step);
    }
    step(0);
  }

  function markCorrect(el){ el.classList.add('correct'); sfx('ok'); confettiBurst(); pieces = Math.min(6, pieces+1); renderProgress(); }
  function markWrong(el){ el.classList.add('wrong'); sfx('bad'); setTimeout(()=> el.classList.remove('wrong'), 400); }

  document.getElementById('startBtn').addEventListener('click', () => { 
  btnReplay.style.display='inline-block';
  try { bgm.currentTime = 0; bgm.play(); } catch(e) {}
  computeOrder();
  gotoScene(questionOrder[0]);
});

  btnReplay.addEventListener('click', () => { location.reload(); });
  btnSound.addEventListener('click', () => { 
    soundsEnabled = !soundsEnabled; 
    btnSound.textContent = soundsEnabled ? 'üîä sons' : 'üîà muet'; 
    bgm.muted = !soundsEnabled;
  });

  // Sc√®nes 1 ‚Üí 5 : mini-jeux
document.querySelectorAll('#scene1 .option').forEach(opt => {
  opt.addEventListener('click', () => {
    if (opt.dataset.correct === 'true') {
      markCorrect(opt);
      setTimeout(() => advanceFromScene(1), 700);
    } else { markWrong(opt); }
  });
});

// Sc√®nes 2
 document.querySelectorAll('#scene2 .option').forEach(opt => {
  opt.addEventListener('click', () => {
    if (opt.dataset.correct === 'true') {
      markCorrect(opt);
      setTimeout(() => advanceFromScene(2), 700);
    } else { markWrong(opt); }
  });
});


  // Sc√®ne 3 (üêº ü¶Å ü¶Ñ)
document.querySelectorAll('#scene3 .option').forEach(opt => {
  opt.addEventListener('click', () => {
    if (opt.dataset.correct === 'true') {
      markCorrect(opt);
      setTimeout(() => advanceFromScene(3), 700);
    } else { markWrong(opt); }
  });
});


  // Sc√®ne 4 (‚öΩÔ∏è, üõù, üéÆ)
 document.querySelectorAll('#scene4 .option').forEach(opt => {
  opt.addEventListener('click', () => {
    if (opt.dataset.correct === 'true') {
      markCorrect(opt);
      setTimeout(() => advanceFromScene(4), 700);
    } else { markWrong(opt); }
  });
});


  // Ancien code ballon/but ‚Äî ignor√© s'il n'existe pas dans le DOM
  const ballon = document.getElementById('ballon');
  const but = document.getElementById('but');
  if (ballon && but) {
    ballon.addEventListener('click', () => {
      const goal = but.getBoundingClientRect();
      const b = ballon.getBoundingClientRect();
      const dx = (goal.left + goal.width/2) - (b.left + 36);
      const dy = (goal.top + goal.height/2) - (b.top + 36);
      ballon.style.transition = 'transform 900ms cubic-bezier(.2,.7,0,1)';
      ballon.style.transform = `translate(${dx}px, ${dy}px)`;
      setTimeout(()=>{
        markCorrect(ballon);
        setTimeout(()=> gotoScene(5), 700);
      }, 920);
    });
  }

 // Sc√®ne 5
document.querySelectorAll('#scene5 .option').forEach(opt => {
  opt.addEventListener('click', () => {
    if (opt.dataset.correct === 'true') {
      markCorrect(opt);
      setTimeout(() => advanceFromScene(5), 700);
    } else { markWrong(opt); }
  });
});


  /* ----------- PUZZLE AVEC FALLBACK D'IMAGE ----------- */
  let PUZZLE_IMG = 'assets/puzzle.jpg';
  const FALLBACKS = ['assets/eden.png','assets/Rose.png','assets/Dimitry.png'];
  const puzzle = document.getElementById('puzzle');
  const cols = 3, rows = 2;
  const slots = [];
  const W = () => puzzle.clientWidth; const H = () => puzzle.clientHeight;

  function testImage(src){
    return new Promise((resolve,reject)=>{
      const im = new Image();
      im.onload = () => resolve(src);
      im.onerror = () => reject(src);
      im.src = src;
    });
  }

  async function resolvePuzzleSrc(){
    const candidates = [PUZZLE_IMG, ...FALLBACKS];
    for(const c of candidates){
      try { await testImage(c); return c; } catch(e){}
    }
    return null;
  }

  function setGuideBackground(src){
    puzzle.style.setProperty('--guide-url', `url("${src}")`);
  }
  const styleEl = document.createElement('style');
  styleEl.textContent = `#puzzle::after{ background-image: var(--guide-url); }`;
  document.head.appendChild(styleEl);

  function makeSlots(src){
    const pieceW = W()/cols;
    const pieceH = H()/rows;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const slot = document.createElement('div');
        slot.className = 'slot';
        Object.assign(slot.style, {
          width:`${pieceW-6}px`, height:`${pieceH-6}px`,
          left:`${c*pieceW+3}px`, top:`${r*pieceH+3}px`,
          backgroundImage: `url("${src}")`,
          backgroundSize: `${W()}px ${H()}px`,
          backgroundPosition: `-${c*pieceW}px -${r*pieceH}px`
        });
        slot.dataset.row=r; slot.dataset.col=c;
        puzzle.appendChild(slot);
        slots.push(slot);
      }
    }
  }
  function clearSlots(){ slots.splice(0, slots.length); Array.from(puzzle.querySelectorAll('.slot')).forEach(n=>n.remove()); }

  function randomAround(min, max){ return Math.random()*(max-min)+min; }

  let placed = 0;
  const totalPieces = cols*rows;

  function spawnPieces(src){
    const pieceW = W()/cols;
    const pieceH = H()/rows;
    for(let i=0;i<totalPieces;i++){
      const piece = document.createElement('div');
      piece.className = 'piece-draggable';
      const r = Math.floor(i/cols), c = i%cols;
      piece.dataset.row=r; piece.dataset.col=c;
      Object.assign(piece.style, {
        width: (pieceW-6)+'px',
        height: (pieceH-6)+'px',
        backgroundImage: `url("${src}")`,
        backgroundSize: `${W()}px ${H()}px`,
        backgroundPosition: `-${c*pieceW}px -${r*pieceH}px`
      });
      const px = randomAround(10, Math.max(12, W()-pieceW-12));
      const py = randomAround(H()+20, H()+120);
      Object.assign(piece.style, { left:`${px}px`, top:`${py}px` });
      puzzle.appendChild(piece);
      requestAnimationFrame(()=>{
        piece.style.transition = 'top 600ms ease';
        piece.style.top = randomAround(H()-pieceH-10, H()-pieceH/2) + 'px';
      });
      enableDrag(piece);
    }
  }

  function enableDrag(el){
    let ox=0, oy=0, dragging=false;
    function down(e){ dragging=true; el.style.transition='none'; const pt = getPoint(e); ox = pt.x - el.offsetLeft; oy = pt.y - el.offsetTop; e.preventDefault(); }
    function move(e){ if(!dragging) return; const pt = getPoint(e); el.style.left = (pt.x-ox)+ 'px'; el.style.top = (pt.y-oy)+'px'; }
    function up(){ if(!dragging) return; dragging=false; snap(el); }
    el.addEventListener('mousedown', down); window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
    el.addEventListener('touchstart', down, {passive:false}); window.addEventListener('touchmove', move, {passive:false}); window.addEventListener('touchend', up);
  }
  function getPoint(e){ if(e.touches && e.touches[0]) return {x:e.touches[0].clientX, y:e.touches[0].clientY}; return {x:e.clientX, y:e.clientY}; }
  function snap(el){
    const r = +el.dataset.row, c = +el.dataset.col;
    const slot = slots.find(s=> +s.dataset.row===r && +s.dataset.col===c);
    const sx = slot.getBoundingClientRect().left - puzzle.getBoundingClientRect().left;
    const sy = slot.getBoundingClientRect().top - puzzle.getBoundingClientRect().top;
    const dx = parseFloat(el.style.left) - sx;
    const dy = parseFloat(el.style.top) - sy;
    const dist = Math.hypot(dx, dy);
    if(dist < 60){
      el.style.left = sx+'px'; el.style.top = sy+'px'; el.style.cursor='default';
      el.style.borderColor = '#10b981'; slot.classList.add('filled');
      el.onmousedown=null; el.ontouchstart=null;
      placed++;
      sfx('ok'); confettiBurst(sx+el.clientWidth/2 + puzzle.getBoundingClientRect().left, sy+el.clientHeight/2 + puzzle.getBoundingClientRect().top);
      if(placed===totalPieces){
        pieces = 6; renderProgress();
        document.getElementById('openChest').style.display='inline-block';
      }
    } else {
      sfx('bad');
    }
  }

  async function setupPuzzle(){
    placed = 0;
    Array.from(puzzle.querySelectorAll('.piece-draggable')).forEach(n=>n.remove());
    clearSlots();
    const src = await resolvePuzzleSrc();
    if(!src){
      document.getElementById('openChest').style.display='none';
      return;
    }
    setGuideBackground(src);
    makeSlots(src);
    spawnPieces(src);
  }

  const openChestBtn = document.getElementById('openChest');
  openChestBtn.addEventListener('click', () => {
    confettiBurst(); fireworks();
    setTimeout(()=> gotoScene(7), 600);
  });

  const obs = new MutationObserver(()=>{
    if(scenes[6].classList.contains('active')){
      setupPuzzle();
    }
  });
  obs.observe(scenes[6], { attributes:true, attributeFilter:['class'] });

  window.addEventListener('resize', () => {
    if(scenes[6].classList.contains('active')){
      setupPuzzle();
    }
  });

  document.getElementById('playAgain').addEventListener('click', () => location.reload());

  /* ------------------ STICKERS MULTI-PROTAGONISTES ------------------ */
  const PROTAGONISTS = [
    { key:'eden',     label:'Eden',           img:'assets/eden.png' },
    { key:'rose',     label:'Rose',           img:'assets/Rose.png' },
    { key:'dimitry',  label:'Dimitry',        img:'assets/Dimitry.png' },
    { key:'cyndel',   label:'Cyndel',         img:'assets/Cyndel.png' },
    { key:'julien',   label:'Papa Julien',    img:'assets/Julien.png' },
    { key:'violette', label:'Maman Violette', img:'assets/Violette.png' },
    { key:'jerome',   label:'Tonton J√©r√¥me',  img:'assets/Jerome.png' },
    { key:'justine',  label:'Tata Justine',   img:'assets/Justine.png' },
    { key:'alison',   label:'Tata Alison',    img:'assets/Alison.png' },
    { key:'maminou',  label:'Maminou',        img:'assets/Maminou.png' },
  ];
  const REQUIRED_PER_CHAR = 3;

  const PLACES = [
    {scene:1, left:'8%',  top:'16%'}, {scene:1, left:'78%', top:'14%'}, {scene:1, left:'16%', top:'68%'}, {scene:1, left:'70%', top:'62%'}, {scene:1, left:'46%', top:'74%'},
    {scene:2, left:'10%', top:'18%'}, {scene:2, left:'80%', top:'18%'}, {scene:2, left:'18%', top:'70%'}, {scene:2, left:'72%', top:'66%'}, {scene:2, left:'46%', top:'14%'},
    {scene:3, left:'12%', top:'22%'}, {scene:3, left:'76%', top:'22%'}, {scene:3, left:'20%', top:'72%'}, {scene:3, left:'68%', top:'70%'}, {scene:3, left:'46%', top:'78%'},
    {scene:4, left:'9%',  top:'20%'}, {scene:4, left:'81%', top:'20%'}, {scene:4, left:'20%', top:'66%'}, {scene:4, left:'68%', top:'68%'}, {scene:4, left:'46%', top:'16%'},
    {scene:5, left:'10%', top:'18%'}, {scene:5, left:'80%', top:'18%'}, {scene:5, left:'18%', top:'72%'}, {scene:5, left:'72%', top:'70%'}, {scene:5, left:'46%', top:'78%'},
    {scene:6, left:'8%',  top:'14%'}, {scene:6, left:'82%', top:'14%'}, {scene:6, left:'14%', top:'74%'}, {scene:6, left:'70%', top:'74%'}, {scene:6, left:'46%', top:'10%'},
  ];

// R√©partition am√©lior√©e : chaque personnage appara√Æt 3x sur 3 sc√®nes diff√©rentes,
// et chaque sc√®ne affiche 5 personnages tous diff√©rents. Les positions sont m√©lang√©es √† chaque partie.
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

// Regroupe les emplacements par sc√®ne et m√©lange l'ordre pour varier les positions
const scenesSlots = {1:[],2:[],3:[],4:[],5:[],6:[]};
PLACES.forEach(pl => { scenesSlots[pl.scene].push(pl); });
Object.values(scenesSlots).forEach(shuffle);

// Phase al√©atoire pour √©viter d‚Äôavoir toujours les m√™mes visages par sc√®ne √† chaque partie
const PHASE = Math.floor(Math.random()*6); // 0..5

const STICKERS = [];
PROTAGONISTS.forEach((p, idx) => {
  // 3 sc√®nes distinctes espac√©es de 2 (ex: 1,3,5), d√©cal√©es par une phase al√©atoire
  const targets = [ ((idx+PHASE)%6)+1, ((idx+PHASE+2)%6)+1, ((idx+PHASE+4)%6)+1 ];
  for (let j=0; j<REQUIRED_PER_CHAR; j++){
    const sc = targets[j];
    const place = scenesSlots[sc].shift(); // prend un slot libre dans cette sc√®ne
    if (place) {
      STICKERS.push({ ...place, key:p.key, label:p.label, img:p.img, id:`st_${p.key}_${j}` });
    }
  }
});


  const game = document.getElementById('game');
  const stickerCounts = Object.fromEntries(PROTAGONISTS.map(p => [p.key, 0]));
  const stickerElems = [];
// --- Randomisation douce des positions des stickers -----------------
const placedByScene = {}; // m√©morise les positions d√©j√† pos√©es dans chaque sc√®ne
function jitterPct(base, spread = 6, min = 4, max = 92) {
  const v = base + (Math.random() * 2 - 1) * spread;
  return Math.max(min, Math.min(max, v));
}
function tooClose(a, b, minDist = 10) {
  const dx = a.left - b.left, dy = a.top - b.top;
  return Math.hypot(dx, dy) < minDist;
}

STICKERS.forEach(s => {
  const el = document.createElement('div');
  el.className = 'sticker';
  el.dataset.scene = s.scene;
  el.dataset.key = s.key;
  el.id = s.id;

  // Position al√©atoirement d√©cal√©e (¬±6%) + anti-collision basique
  if (!placedByScene[s.scene]) placedByScene[s.scene] = [];
  const baseL = parseFloat(s.left);
  const baseT = parseFloat(s.top);
  let candidate = { left: jitterPct(baseL), top: jitterPct(baseT) };
  let tries = 0;
  while (placedByScene[s.scene].some(p => tooClose(p, candidate)) && tries < 12) {
    candidate = { left: jitterPct(baseL), top: jitterPct(baseT) };
    tries++;
  }
  placedByScene[s.scene].push(candidate);
  el.style.left = candidate.left + '%';
  el.style.top  = candidate.top  + '%';

  el.style.display = 'none';
  el.innerHTML = `<img src="${s.img}" alt="${s.label}" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">`;
  el.addEventListener('click', () => {
    sfx('ok');
    const rect = el.getBoundingClientRect();
    confettiBurst(rect.left + rect.width/2, rect.top + rect.height/2);
    el.dataset.collected = '1';
    el.style.display = 'none';
    stickerCounts[s.key] = Math.min(REQUIRED_PER_CHAR, stickerCounts[s.key] + 1);
  });

  game.appendChild(el);
  stickerElems.push(el);
});

  function toggleStickers(){
    stickerElems.forEach(el => {
      const sc = +el.dataset.scene;
      const collected = el.dataset.collected === '1';
      if(sc === current && !collected){
        el.style.display = 'grid';
      } else {
        el.style.display = 'none';
      }
    });
  }

  const wall = document.getElementById('stickersWall');
  const wallObs = new MutationObserver(()=>{
    if(scenes[7].classList.contains('active')){
      const parts = PROTAGONISTS.map(p => {
        const c = stickerCounts[p.key] || 0;
        const ok = c >= REQUIRED_PER_CHAR ? '‚úÖ' : '‚è≥';
        return `${p.label}: ${c}/${REQUIRED_PER_CHAR} ${ok}`;
      });
      const allDone = PROTAGONISTS.every(p => (stickerCounts[p.key]||0) >= REQUIRED_PER_CHAR);
      wall.textContent = parts.join(' ¬∑ ') + (allDone ? ' ¬∑ Super, tu as tout trouv√© !' : ' ¬∑ Tu feras encore mieux la prochaine fois !');
    }
  });
  wallObs.observe(scenes[7], { attributes:true, attributeFilter:['class'] });

  // D√©marrage audio sur premi√®re interaction
  const __oneShot = () => { if (bgm.paused) { bgm.play().catch(()=>{}); } document.removeEventListener('pointerdown', __oneShot); };
  document.addEventListener('pointerdown', __oneShot, { once:true });

})();
</script>
</body>
</html>
